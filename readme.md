# Regular Expression Engine with AND and NOT operators

## これなに？

Rust製の正規表現エンジンです。
通常の 連接 (` `) 、選言 (`\|`) 、Kneene star (`*`) に加えて 連言 (`\&`) と 否定 (`\~`) に対応しています。
マッチ処理は正規表現の微分 (regular expression derivative) を用いて実装されています。

## 文法

基本はBREです。

| 正規表現 | マッチする対象 |
|---|---|
| `.` | 任意の一文字 |
| `[abc]` | 括弧内に含まれる一文字 |
| `[^abc]` | 括弧内に含まれない一文字 |
| `a*` | `a` の0回以上の繰り返し |
| `a\+` | `a` の1回以上の繰り返し |
| `a\?` | 空文字列または `a` |
| `a\~` | `a` にマッチしない文字列 |
| `a\&b` | `a` にも `b` にもマッチする文字列 |
| `a\|b` | `a` か `b` のどちらかにマッチする文字列 |
| `\(abc\)` | 括弧内の正規表現にマッチする文字列 (グルーピング) |

### 例

-   `a\~`: `a` 以外の任意の文字列 (`b` `c` `hoge` `fuga` など)
-   `\(regexp\)\~`: `regexp` 以外の任意の文字列
-   `0\&1`: `0` にも `1` にもマッチするような文字列 (存在しない)
-   `\(regexp\)\~\&\(.*p\)`: `p` で終わる文字列であって `regexp` ではないもの
-   `a\&b\|c`: `a` にも `b` にもマッチする文字列、あるいは `c` にマッチする文字列 (`c` のみ)
-   `a\~*`: `a` ではない文字列の0回以上の繰り返しでは書くことのできない文字列 (`a` のみ)
-   `a\~*\~*\~`: `a` ではない文字列の0回以上の繰り返しでは書くことのできない文字列の0回以上の繰り返しでは書くことのできない文字列 (`a` 以外の文字を含む文字列)

## 動作例

``` sed
$ cargo run -q '\(regexp\)\~\&\(.*p\)' exp
input regexp text:  \(regexp\)\~\&\(.*p\)
parsed text: \(regexp\)\~\&.*p
d(e): .*p
d(x): .*p
d(p): .*p\|
match: true
```

``` sed
$ cargo run -q '\(regexp\)\~\&\(.*p\)' regexp
input regexp text:  \(regexp\)\~\&\(.*p\)
parsed text: \(regexp\)\~\&.*p
d(r): \(egexp\)\~\&.*p
d(e): \(gexp\)\~\&.*p
d(g): \(exp\)\~\&.*p
d(e): \(xp\)\~\&.*p
d(x): p\~\&.*p
d(p): \(\)\~\&\(.*p\|\)
match: false
```

``` sed
$ cargo run -q '\(regexp\)\~\&\(.*p\)' regexpp
input regexp text:  \(regexp\)\~\&\(.*p\)
parsed text: \(regexp\)\~\&.*p
d(r): \(egexp\)\~\&.*p
d(e): \(gexp\)\~\&.*p
d(g): \(exp\)\~\&.*p
d(e): \(xp\)\~\&.*p
d(x): p\~\&.*p
d(p): \(\)\~\&\(.*p\|\)
d(p): .*p\|
match: true
```

``` sed
$ cargo run -q '[^あ-ん]\~' 'ぁ'
input regexp text:  [^あ-ん]\~
parsed text: [^あ-ん]\~
d(ぁ): \(\)\~
match: false
```

## メモ

-   表現力はちょうど正則言語。 AND は DFA の有向グラフとしての直積を、 NOT は DFA の受理状態の集合を反転させることを考えればよく、これは保守的な拡張になっています。
-   DFA の構築をしようとするとその過程の epsilon-NFA に対する AND と NOT が局所的な繋ぎ合わせにならないため手間が多い。微分を用いるとかなり楽でした。
-   最悪計算量は指数。多項式へ落とすのはどれだけ正規表現の単純化を頑張るかに依存するのだけれど、例えば `\(\(ab\)**\(ab\)**\|ab\)***` を `\(ab\)*` へ書き直すなどが必要なのでかなり難しそう。
-   NOT を構文論的に除去するのは簡単。AND はできるでしょうがかなり面倒そうです。 AND も NOT 含めたまま丸ごと微分した方が楽そうだったのでそのようにしています。
